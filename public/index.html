<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>BagJump</title>
    <style>
      :root {
        --bg1: #020a05;
        --bg2: #001b0f;
        --fg: #e6ffe8;
        --accent: #6bffa6;
        --accent-2: #00e07d;
        --danger: #ff5a5a;
      }
      * { box-sizing: border-box; }
      html, body {
        height: 100%;
        margin: 0;
        background: radial-gradient(1200px 800px at 70% -10%, #00331e 0%, var(--bg1) 55%),
                    linear-gradient(180deg, var(--bg2), #000703 70%);
        color: var(--fg);
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      }
      .wrap {
        height: 100%;
        display: grid;
        place-items: center;
        padding: 12px;
        position: relative;
        z-index: 1;
      }
      .frame {
        position: relative;
        width: min(92vw, 520px);
        aspect-ratio: 9/16;
        border-radius: 16px;
        overflow: hidden;
        box-shadow: 0 20px 60px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.06);
        background: linear-gradient(180deg, #02140b 0%, #020805 100%);
      }
      canvas { width: 100%; height: 100%; display: block; }

      #matrixBG { position: fixed; inset: 0; z-index: 0; pointer-events: none; opacity: .8; }

      .ui { position: absolute; inset: 0; pointer-events: none; font-weight: 600; z-index: 2; }
      .hud {
        position: absolute; left: 12px; top: 10px; right: 12px; display: flex; justify-content: space-between; align-items: center; gap: 8px; pointer-events: none;
      }
      .pill { background: rgba(255,255,255,.08); backdrop-filter: blur(6px); padding: 8px 10px; border-radius: 999px; box-shadow: inset 0 0 0 1px rgba(255,255,255,.07); }
      .score { font-size: 18px; letter-spacing: .4px; }
      .best  { opacity: .85; font-size: 14px; }

      .menu, .gameover, .paused {
        position: absolute; inset: 0; display: grid; place-items: center; text-align: center; background: linear-gradient(180deg, rgba(0,0,0,.36), rgba(0,0,0,.55));
      }
      .panel {
        pointer-events: auto; max-width: 86%; padding: 20px 18px; border-radius: 16px; background: rgba(18,22,40,.9);
        box-shadow: 0 20px 60px rgba(0,0,0,.4), inset 0 0 0 1px rgba(255,255,255,.08);
      }
      .title { font-size: 28px; font-weight: 900; letter-spacing: .5px; margin: 0 0 6px; }
      .subtitle { opacity: .85; margin: 0 0 14px; }
      .btns { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
      button {
        pointer-events: auto; cursor: pointer; background: linear-gradient(180deg, var(--accent), #45caa0);
        color: #02251a; font-weight: 800; border: 0; padding: 10px 14px; border-radius: 12px; font-size: 16px;
        box-shadow: 0 6px 18px rgba(126,247,200,.35);
      }
      button.secondary { background: linear-gradient(180deg, #a7ffcf, #5df2a2); color: #042217; box-shadow: 0 6px 18px rgba(93,242,162,.32); }
      .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background: rgba(255,255,255,.08); padding: 2px 8px; border-radius: 999px; }

      .scores {
        margin-top: 14px; text-align: left; display: grid; gap: 6px; color: #dfe7ff;
      }
      .scores h4 { margin: 0 0 6px; font-size: 14px; opacity: .8; }
      .scores .row { display: flex; justify-content: space-between; gap: 8px; font-variant-numeric: tabular-nums; }

      /* Mobile touch buttons */
      .touch {
        position: absolute; inset: 0; display: grid; grid-template-columns: 1fr 1fr; align-items: end; gap: 0; padding: 10px; pointer-events: none;
      }
      .touch .pad { pointer-events: auto; height: 86px; background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02)); border-radius: 14px; display: grid; place-items: center; color: #cfe8ff; user-select: none; touch-action: none; }
      .touch .pad:active { background: linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.06)); }
      .touch .shoot { position: absolute; right: 10px; bottom: 108px; width: 86px; height: 86px; border-radius: 50%; background: linear-gradient(180deg, var(--accent-2), #00b86a); pointer-events: auto; display: grid; place-items: center; color: white; font-weight: 900; box-shadow: 0 8px 28px rgba(0,255,150,.25); }

      .uploader { display:grid; gap:8px; margin-top:12px; font-size:13px; }
      .uploader label { display:flex; align-items:center; justify-content:space-between; gap:8px; background: rgba(255,255,255,.06); padding:8px 10px; border-radius:10px; }
      .uploader input[type="file"] { pointer-events:auto; }

      @media (min-width: 860px) { .touch { display: none; } }

      /* Twitter button (fixed, on matrix background) */
      .twitter-fixed { position: fixed; top: 14px; right: 16px; width: 52px; height: 52px; border-radius: 50%;
        background: rgba(0,0,0,.35); display: grid; place-items: center; pointer-events: auto; text-decoration: none;
        box-shadow: 0 8px 18px rgba(0,0,0,.4), inset 0 0 0 2px rgba(0,255,170,.25); z-index: 3; }
      .twitter-fixed:hover { background: rgba(0,0,0,.5); box-shadow: 0 8px 18px rgba(0,0,0,.5), inset 0 0 0 2px rgba(0,255,170,.45); }
      .twitter-fixed span { filter: drop-shadow(0 1px 2px rgba(0,0,0,.6)); }
    </style>
  </head>
  <body>
    <canvas id="matrixBG"></canvas>
    <a id="twitterBtn" class="twitter-fixed" href="#" target="_blank" title="Twitter">
      <span>
        <svg width="28" height="28" viewBox="0 0 24 24" fill="#00acee" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <path d="M22.46 6c-.77.35-1.6.58-2.46.69.89-.53 1.57-1.36 1.89-2.36-.83.49-1.75.84-2.73 1.03A4.15 4.15 0 0 0 15.5 4c-2.3 0-4.16 1.9-4.16 4.24 0 .33.03.65.1.95-3.46-.18-6.53-1.9-8.58-4.5-.36.64-.57 1.38-.57 2.17 0 1.5.73 2.83 1.83 3.6-.67-.02-1.3-.21-1.85-.51v.05c0 2.1 1.45 3.85 3.37 4.25-.35.1-.73.15-1.11.15-.27 0-.54-.03-.79-.07.54 1.77 2.12 3.06 3.98 3.1A8.32 8.32 0 0 1 2 19.54 11.77 11.77 0 0 0 8.29 21c7.55 0 11.68-6.4 11.68-11.95 0-.18 0-.36-.01-.54.8-.6 1.49-1.35 2.04-2.2Z"/>
        </svg>
      </span>
    </a>
    <div class="wrap">
      <div class="frame" id="frame">
        <canvas id="game" width="450" height="800" aria-label="BagJump Spiel" style="position:absolute; inset:0; z-index:1;"></canvas>

        <div class="ui">
          <div class="hud">
            <div class="pill score" id="score">0</div>
            <div class="pill best" id="best">Best: 0</div>
          </div>

          <div class="menu" id="menu">
            <div class="panel">
              <p class="title">BagJump</p>
              <p class="subtitle">Jump higher, shoot enemies, and beat the high score. <br><br> <em>The winner takes all Fees</em><br> CA:</p>
              <div style="font-size:14px;opacity:.9;margin-bottom:12px;">
                Controls: <span class="kbd">A</span>/<span class="kbd">←</span> & <span class="kbd">D</span>/<span class="kbd">→</span> to move, <span class="kbd">Space</span>/<span class="kbd">Click</span> to shoot, <span class="kbd">P</span> pause.
              </div>
              <div style="display:flex; gap:8px; justify-content:center; align-items:center; margin-bottom:10px;">
                <label for="playerName" style="opacity:.9;">Name:</label>
                <input id="playerName" type="text" maxlength="18" placeholder="Your name" style="pointer-events:auto;padding:8px 10px;border-radius:10px;border:0;background:rgba(255,255,255,.08);color:var(--fg);min-width:160px;">
              </div>
                                           <div class="btns">
                <button id="startBtn">Start</button>
                <button class="secondary" id="muteBtn">Sound On/Off</button>
              </div>
              <div class="scores" id="scoreList"></div>
            </div>
          </div>

          <div class="paused" id="paused" style="display:none;">
            <div class="panel">
              <p class="title">Paused</p>
              <p class="subtitle">Press <span class="kbd">P</span> to resume.</p>
              <div class="btns"><button id="resumeBtn">Resume</button></div>
            </div>
          </div>

          <div class="gameover" id="gameover" style="display:none;">
            <div class="panel">
              <p class="title">Game Over</p>
              <p class="subtitle" id="finalScore">Score: 0</p>
              <div class="btns">
                <button id="againBtn">Retry</button>
                <button class="secondary" id="toMenuBtn">Menu</button>
              </div>

            </div>
          </div>

          <div class="touch" id="touch">
            <div class="pad" id="leftPad">←</div>
            <div class="pad" id="rightPad">→</div>
            <div class="shoot" id="shootPad">●</div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // Core helpers
      const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
      const rand = (min, max) => Math.random() * (max - min) + min;
      const choice = arr => arr[Math.floor(Math.random() * arr.length)];

      // Basic sound generator (very tiny bleep using WebAudio)
      const SFX = (() => {
        let ctx; const ensure = () => (ctx ||= new (window.AudioContext || window.webkitAudioContext)());
        const beep = (freq = 440, dur = 0.08, type = 'triangle', gain = 0.03) => {
          if (muted) return; const a = ensure(); const t = a.currentTime;
          const o = a.createOscillator(); const g = a.createGain();
          o.type = type; o.frequency.setValueAtTime(freq, t);
          g.gain.setValueAtTime(gain, t); g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
          o.connect(g).connect(a.destination); o.start(t); o.stop(t + dur);
        };
        return { beep };
      })();

      // Image loader with graceful fallback
      function loadImage(src, onReady) {
        const img = new Image();
        img.onload = () => onReady(img, true);
        img.onerror = () => onReady(img, false);
        img.src = src;
      }
      function loadAny(urls, assign) {
        const list = urls.slice();
        const tryNext = () => {
          if (!list.length) return;
          const url = list.shift();
          loadImage(url, (img, ok) => { if (ok) assign(img); else tryNext(); });
        };
        tryNext();
      }

      // Canvas + context
      const matrixCanvas = document.getElementById('matrixBG');
      const mctx = matrixCanvas.getContext('2d');
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      function resizeCanvasToDisplaySize() {
        // keep internal resolution stable (450x800) for physics; CSS handles display
        // no-op; internal size already set
      }
      // Matrix background state
      const matrix = { fontSize: 16, columns: 0, drops: [], chars: 'アイウエオカキクケコサシスセソ0123456789$#*/+<>=-' };
      function resizeMatrix() {
        matrixCanvas.width = window.innerWidth; matrixCanvas.height = window.innerHeight;
        matrix.columns = Math.floor(matrixCanvas.width / (matrix.fontSize * 0.8)); // mehr Spalten = mehr Zeichen
        matrix.drops = new Array(matrix.columns).fill(0).map(()=> Math.random()* (matrixCanvas.height/matrix.fontSize));
      }
      window.addEventListener('resize', resizeMatrix); resizeMatrix();

      // Game state
      const State = { MENU: 0, PLAY: 1, PAUSE: 2, OVER: 3 };
      let state = State.MENU;
      let muted = true; // default silent; player can enable

      // Assets: player + two enemies. Load from files if present or from user uploads (stored in localStorage)
      const assets = { player: null, enemy1: null, enemy2: null };
      const UP_KEYS = { player: 'bagjump.img.player', enemy1: 'bagjump.img.enemy1', enemy2: 'bagjump.img.enemy2' };
      function fromLS(key) { try { return localStorage.getItem(key); } catch { return null; } }
      const lsPlayer = fromLS(UP_KEYS.player), lsE1 = fromLS(UP_KEYS.enemy1), lsE2 = fromLS(UP_KEYS.enemy2);
      
             // Load images with better error handling and retry logic
       function loadPlayerImage() {
         const urls = [lsPlayer, 'Spieler.png', 'Spieler.jpg', './Spieler.png', './Spieler.jpg', 'player.png', 'player.jpg'].filter(Boolean);
         loadAny(urls, (img) => {
           if (img && img.complete && img.naturalWidth > 0) {
             assets.player = img;
             console.log('Player image loaded: success');
           } else {
             console.log('Player image loaded: fallback');
           }
         });
       }
       
       function loadEnemyImages() {
         const urls1 = [lsE1, 'Gegner1.jpg', 'Gegner1.png', './Gegner1.jpg', './Gegner1.png', 'enemy1.png', 'enemy1.jpg'].filter(Boolean);
         const urls2 = [lsE2, 'Gegner2.jpg', 'Genger2.jpg', './Gegner2.jpg', './Genger2.jpg', 'enemy2.png', 'enemy2.jpg'].filter(Boolean);
         
         loadAny(urls1, (img) => {
           if (img && img.complete && img.naturalWidth > 0) {
             assets.enemy1 = img;
             console.log('Enemy1 image loaded: success');
           } else {
             console.log('Enemy1 image loaded: fallback');
           }
         });
         loadAny(urls2, (img) => {
           if (img && img.complete && img.naturalWidth > 0) {
             assets.enemy2 = img;
             console.log('Enemy2 image loaded: success');
           } else {
             console.log('Enemy2 image loaded: fallback');
           }
         });
       }
      
             // Load images with retry
       loadPlayerImage();
       loadEnemyImages();
       
       // Retry loading if images fail after 2 seconds
       setTimeout(() => {
         if (!assets.player) {
           console.log('Retrying player image load...');
           loadPlayerImage();
         }
         if (!assets.enemy1 || !assets.enemy2) {
           console.log('Retrying enemy image load...');
           loadEnemyImages();
         }
       }, 2000);
       
       // Additional retry after 5 seconds
       setTimeout(() => {
         if (!assets.player) {
           console.log('Final retry player image load...');
           loadPlayerImage();
         }
         if (!assets.enemy1 || !assets.enemy2) {
           console.log('Final retry enemy image load...');
           loadEnemyImages();
         }
       }, 5000);

      // Input
      const keys = new Set();
             document.addEventListener('keydown', (e) => {
         // Only prevent default for game controls, not when typing in input fields
         if (e.target.tagName === 'INPUT') return;
         if (['ArrowLeft', 'ArrowRight', ' ', 'Spacebar', 'a', 'A', 'd', 'D', 'p', 'P'].includes(e.key)) e.preventDefault();
         if (e.key === 'p' || e.key === 'P') togglePause();
         keys.add(e.key);
       });
      document.addEventListener('keyup', (e) => { keys.delete(e.key); });
      canvas.addEventListener('pointerdown', () => { if (state === State.PLAY) shoot(); });

      // Touch buttons
      const leftPad = document.getElementById('leftPad');
      const rightPad = document.getElementById('rightPad');
      const shootPad = document.getElementById('shootPad');
      const activeTouches = { left: false, right: false };
      const setActive = (k, v) => (activeTouches[k] = v);
      ['pointerdown','pointerup','pointerleave','pointercancel'].forEach(type => {
        leftPad.addEventListener(type, (e) => { e.preventDefault(); setActive('left', type==='pointerdown'); });
        rightPad.addEventListener(type, (e) => { e.preventDefault(); setActive('right', type==='pointerdown'); });
      });
      ['pointerdown'].forEach(type => { shootPad.addEventListener(type, (e) => { e.preventDefault(); shoot(); }); });

      // UI elements
      const ui = {
        score: document.getElementById('score'),
        best: document.getElementById('best'),
        menu: document.getElementById('menu'),
        paused: document.getElementById('paused'),
        over: document.getElementById('gameover'),
        final: document.getElementById('finalScore'),
        listMenu: document.getElementById('scoreList'),

        start: document.getElementById('startBtn'),
        again: document.getElementById('againBtn'),
        toMenu: document.getElementById('toMenuBtn'),
        resume: document.getElementById('resumeBtn'),
        mute: document.getElementById('muteBtn')
      };
      ui.start.addEventListener('click', startGame);
      ui.again && ui.again.addEventListener('click', startGame);
      ui.toMenu && ui.toMenu.addEventListener('click', () => gotoMenu());
      ui.resume && ui.resume.addEventListener('click', () => togglePause(true));
      ui.mute && ui.mute.addEventListener('click', () => { muted = !muted; SFX.beep(660, .03); });
      // Twitter button link - set your profile URL here
      const twitterBtn = document.getElementById('twitterBtn');
      if (twitterBtn) {
        twitterBtn.href = 'https://twitter.com/bagsyjump'; // TODO: set your handle URL
      }

      // Score persistence - Global only
      const NAME_KEY = 'bagjump.playerName.v1';
      const API_BASE = '/api/leaderboard'; // Redis API
      
      function saveScore(s) {
        const nameInput = document.getElementById('playerName');
        const name = (nameInput?.value || 'Player').slice(0,18);
        try { localStorage.setItem(NAME_KEY, name); } catch {}
        // submit to global board
        submitGlobalScore(name, s).catch(()=>{});
      }
      
      async function renderScoreLists() {
        // Fetch global highscores only
        try {
          const global = await fetchGlobalScores();
          let gHtml = '<div class="row">Loading global scores...</div>';
          if (global && Array.isArray(global) && global.length) {
            gHtml = global.slice(0,8).map((r,i)=> `<div class="row"><div>#${i+1}</div><div>${escapeHtml(r.name || 'Player')}</div><div>${r.score|0}</div></div>`).join('');
          } else {
            gHtml = '<div class="row">No global scores yet</div>';
          }
          ui.listMenu.innerHTML = '<h4>Global Highscores</h4>' + gHtml;
        } catch (error) {
          ui.listMenu.innerHTML = '<h4>Global Highscores</h4><div class="row">Failed to load</div>';
        }
      }

      function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c])); }

      async function submitGlobalScore(name, score){
        const res = await fetch(API_BASE, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ name, score }) });
        if (!res.ok) throw new Error('submit failed');
        return res.json();
      }
             async function fetchGlobalScores(){
         const res = await fetch(API_BASE);
         if (!res.ok) return null;
         return res.json();
       }
       

       


      // World objects
      let player, platforms, enemies, bullets, cameraY, score, lastShotAt, rngSeed;
      let powerups;
      let nextEnemyScoreAt = 1000;
      const config = {
        gravity: 1400,
        jumpForce: 760,
        moveSpeed: 300,
        bulletSpeed: 1000,
        fireCooldownMs: 130,
         platformGapMin: 100,
         platformGapMax: 160,
        movingPlatformChance: 0.18,
        breakPlatformChance: 0.12,
        enemyChance: 0.0,
      };

             function initWorld() {
         score = 0; cameraY = 0; lastShotAt = 0; rngSeed = Math.floor(Math.random() * 1e9); nextEnemyScoreAt = 1000;
         player = { x: canvas.width/2, y: canvas.height - 80, w: 50, h: 58, vx: 0, vy: -800, alive: true };
         // Don't override the name input if user has already typed something
         const nameInput = document.getElementById('playerName');
         if (nameInput && !nameInput.value.trim()) {
           const savedName = localStorage.getItem(NAME_KEY);
           if (savedName) nameInput.value = savedName;
         }
        bullets = []; enemies = []; platforms = []; powerups = [];
        // base floor platform
        platforms.push({ x: canvas.width/2 - 40, y: canvas.height - 30, w: 80, type: 'solid', vx: 0, broken: false });
        // generate upwards
        let y = canvas.height - 130;
        while (y > -2000) {
          addPlatformRow(y); y -= rand(config.platformGapMin, config.platformGapMax);
        }
      }

             function maybeSpawnEnemyByScore() {
         if (score >= nextEnemyScoreAt) {
           addEnemy(minPlatformY() - rand(120, 260));
           nextEnemyScoreAt += 700; // ~40% häufiger als 1000
         }
       }
       
       // Track if we just got a rocket boost to prevent enemy spam
       let justGotRocketBoost = false;

             function addPlatformRow(y) {
         const w = rand(60, 110); // Back to original size
         const x = rand(10, canvas.width - w - 10);
        let type = 'solid';
        if (Math.random() < config.breakPlatformChance) type = 'break';
        else if (Math.random() < config.movingPlatformChance) type = 'move';
                                   platforms.push({ x, y, w, type, vx: type==='move' ? rand(40, 80) * (Math.random()<.5?-1:1) : 0, broken: false, willBreak: false });
                   // occasional power-up spawn on platform line (rare)
                                               if (Math.random() < 0.034) { // 30% increase from 0.026 to 0.034
              if (Math.random() < 0.5) { // 50/50 chance between rocket and hat
                addRocket(x + w/2 - 19, y - 45); // moved up a bit
              } else {
                addHat(x + w/2 - 19, y - 45);
              }
            }
      }

                           // Power-ups
        const rocketImg = new Image(); rocketImg.src = 'rakete.png';
        const hatImg = new Image(); hatImg.src = 'hat.png';
       function addRocket(x, y) { powerups.push({ type: 'rocket', x, y, w: 38, h: 38, taken: false }); }
       function addHat(x, y) { powerups.push({ type: 'hat', x, y, w: 38, h: 38, taken: false }); }

      function addEnemy(y) {
        const size = rand(40, 64);
        enemies.push({ x: rand(10, canvas.width - size - 10), y, w: size, h: size, vx: rand(60, 120) * (Math.random()<.5?-1:1), hp: 1, sprite: Math.random()<.5? 'enemy1':'enemy2' });
      }

      function shoot() {
        if (state !== State.PLAY) return;
        const now = performance.now();
        if (now - lastShotAt < config.fireCooldownMs) return;
        lastShotAt = now;
        bullets.push({ x: player.x + player.w/2 - 3, y: player.y - 6, w: 6, h: 10, vy: -config.bulletSpeed });
        SFX.beep(920, .05, 'square', .04);
      }

      function startGame() {
        initWorld();
        ui.menu.style.display = 'none';
        ui.over.style.display = 'none';
        document.getElementById('touch').style.display = '';
        state = State.PLAY;
      }
      async function gotoMenu() {
        state = State.MENU; await renderScoreLists(); ui.menu.style.display = '';
        ui.over.style.display = 'none'; document.getElementById('touch').style.display = '';
      }
      async function endGame() {
        state = State.OVER; saveScore(Math.floor(score)); await renderScoreLists();
        ui.final.textContent = 'Score: ' + Math.floor(score);
        ui.over.style.display = '';
        document.getElementById('touch').style.display = 'none';
      }
      function togglePause(forceResume = false) {
        if (state === State.MENU || state === State.OVER) return;
        if (forceResume || state === State.PAUSE) { state = State.PLAY; ui.paused.style.display = 'none'; }
        else { state = State.PAUSE; ui.paused.style.display = ''; }
      }

      // Physics and update loop
      let last = 0;
      function loop(ts) {
        requestAnimationFrame(loop);
        if (!last) last = ts; const dt = Math.min(1/30, (ts - last) / 1000); last = ts;
        drawMatrix();
        if (state === State.PLAY) update(dt);
        draw();
      }
      requestAnimationFrame(loop);

      function update(dt) {
        // Horizontal input
        let dir = 0;
        if (keys.has('ArrowLeft') || keys.has('a') || keys.has('A') || activeTouches.left) dir -= 1;
        if (keys.has('ArrowRight') || keys.has('d') || keys.has('D') || activeTouches.right) dir += 1;
        player.vx = dir * config.moveSpeed;
        player.x += player.vx * dt;
        if (keys.has(' ') || keys.has('Spacebar')) shoot();

        // Screen wrap
        if (player.x + player.w < 0) player.x = canvas.width - 1;
        if (player.x > canvas.width) player.x = -player.w + 1;

        // Gravity
        player.vy += config.gravity * dt;
        player.y += player.vy * dt;

        // Platforms movement
        for (const p of platforms) {
          if (p.type === 'move') {
            p.x += p.vx * dt; if (p.x < 10 || p.x + p.w > canvas.width - 10) p.vx *= -1;
          }
        }

        // Power-ups movement (follow world scroll only)
        for (const pu of powerups) {
          // no intrinsic movement for rocket
        }

                 // Collision: player landing on platform (from above only). Break platforms allow one jump, then crumble after takeoff.
         if (player.vy > 0) {
           let landed = false;
           for (const p of platforms) {
             if (p.broken || landed) continue;
             
             // Better hitbox: use bottom center of player for landing detection
             const playerBottomCenterX = player.x + player.w / 2;
             const playerBottomY = player.y + player.h;
             
             // Check if player is falling onto platform with more generous detection
             if (playerBottomY <= p.y + 2 && playerBottomY + player.vy * dt >= p.y - 2) {
               // Check if player's bottom center is within platform bounds (with some tolerance)
               const tolerance = 10; // pixels of tolerance - increased for better landing
               if (playerBottomCenterX >= p.x - tolerance && playerBottomCenterX <= p.x + p.w + tolerance) {
                 // landed
                 player.y = p.y - player.h; 
                 player.vy = -config.jumpForce; 
                 landed = true; // prevent multiple landings in same frame
                 SFX.beep(500 + Math.random()*60, .05);
                 if (p.type === 'move') player.x += p.vx * 0.02;
                 // mark break platforms to crumble right after jump
                 if (p.type === 'break') { p.willBreak = true; }
                 break; // exit loop after landing
               }
             }
           }
         }

        // Apply crumble for break platforms once the player has left them
        for (const p of platforms) {
          if (p.type === 'break' && p.willBreak && !p.broken) {
            if (!(player.y + player.h <= p.y + 1 && player.y + player.h >= p.y - 80)) {
              // player has left; break it
              p.broken = true; p.willBreak = false; SFX.beep(200, .05, 'sawtooth', .03);
            }
          }
        }

        // Bullets
        for (const b of bullets) b.y += b.vy * dt;
        bullets = bullets.filter(b => b.y > -30);

        // Enemies movement
        for (const e of enemies) {
          e.x += e.vx * dt;
          if (e.x < 0 || e.x + e.w > canvas.width) e.vx *= -1;
        }

        // Bullet vs enemy
        outer: for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          for (let j = bullets.length - 1; j >= 0; j--) {
            const b = bullets[j];
            if (b.x < e.x + e.w && b.x + b.w > e.x && b.y < e.y + e.h && b.y + b.h > e.y) {
              enemies.splice(i, 1); bullets.splice(j, 1); score += 120; SFX.beep(220, .06, 'square', .05); continue outer;
            }
          }
        }

        // Player vs enemy (stomp to kill if falling)
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          if (player.x < e.x + e.w && player.x + player.w > e.x && player.y < e.y + e.h && player.y + player.h > e.y) {
            if (player.vy > 0 && player.y + player.h - e.y < 18) {
              // stomp
              enemies.splice(i,1); player.vy = -config.jumpForce * 0.9; score += 150; SFX.beep(620, .05);
            } else {
              return endGame();
            }
          }
        }

        // Camera follow upward; if player goes up past 40% of screen height, scroll world down
        const targetY = canvas.height * 0.4;
        if (player.y < targetY) {
          const dy = targetY - player.y; player.y += dy; cameraY += dy; score += dy * 0.5; // scoring by ascent
          for (const p of platforms) p.y += dy;
          for (const e of enemies) e.y += dy;
          for (const b of bullets) b.y += dy;
          for (const pu of powerups) pu.y += dy;
          // recycle platforms that go off-screen bottom, add new above
          for (let i = platforms.length - 1; i >= 0; i--) {
            if (platforms[i].y > canvas.height + 40) platforms.splice(i, 1);
          }
                     while (minPlatformY() > -120) addPlatformRow(minPlatformY() - rand(config.platformGapMin, config.platformGapMax));
           // spawn enemy every 1000 score increments (approx meters), but not if we just got a rocket boost
           if (!justGotRocketBoost) {
             maybeSpawnEnemyByScore();
           }
           // Reset rocket boost flag after a short delay
           if (justGotRocketBoost) {
             setTimeout(() => { justGotRocketBoost = false; }, 2000);
           }
        }

        // Death if falling off bottom
        if (player.y > canvas.height + 40) return endGame();

        // UI score
        ui.score.textContent = Math.floor(score).toString();

                                   // Power-up collisions
          for (let i = powerups.length - 1; i >= 0; i--) {
            const pu = powerups[i];
            if (pu.type === 'rocket' && !pu.taken) {
              if (rectsOverlap(player, pu)) {
                pu.taken = true; powerups.splice(i,1);
                player.vy = -rand(1000, 2000); // random boost between 1000-2000
                score += 1000; // 1000 points as requested
                justGotRocketBoost = true; // mark that we just got a rocket boost
                SFX.beep(900, .06, 'sawtooth', .05);
                SFX.beep(600, .12, 'sawtooth', .05);
              }
                         } else if (pu.type === 'hat' && !pu.taken) {
               if (rectsOverlap(player, pu)) {
                 pu.taken = true; powerups.splice(i,1);
                 score += 1000; // 1000 points, no boost
                 console.log('Hat collected! Score before:', score - 1000, 'Score after:', score);
                 SFX.beep(800, .05, 'triangle', .04);
                 SFX.beep(1000, .08, 'triangle', .04);
               }
             }
          }
      }

      function minPlatformY() { let m = Infinity; for (const p of platforms) m = Math.min(m, p.y); return m; }

      function draw() {
        const w = canvas.width, h = canvas.height;
        // sky background, black-green theme
        ctx.clearRect(0, 0, w, h);
        const g = ctx.createLinearGradient(0, 0, 0, h);
        g.addColorStop(0, '#00190f'); g.addColorStop(1, '#000904');
        ctx.fillStyle = g; ctx.fillRect(0, 0, w, h);
        ctx.fillStyle = 'rgba(160,255,200,.14)';
        for (let i = 0; i < 40; i++) ctx.fillRect((i*97 + (cameraY*0.1)%w)%w, (i*53)%h, 2, 2);

        // platforms
        for (const p of platforms) drawPlatform(p);

        // enemies
        for (const e of enemies) drawEnemy(e);

        // powerups
        for (const pu of powerups) drawPowerup(pu);

        // bullets
        ctx.fillStyle = '#b5ffe0';
        for (const b of bullets) {
          ctx.fillRect(b.x, b.y, b.w, b.h);
        }

        // player
        drawPlayer();

        // HUD gloss
        ctx.fillStyle = 'rgba(255,255,255,.03)'; ctx.fillRect(0,0,w,54);
      }

      function rectsOverlap(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }

      function drawMatrix() {
        const w = matrixCanvas.width, h = matrixCanvas.height;
        // lower alpha to keep trails longer visible
        mctx.fillStyle = 'rgba(0, 10, 5, 0.12)';
        mctx.fillRect(0, 0, w, h);
        mctx.font = matrix.fontSize + 'px monospace';
        for (let i = 0; i < matrix.drops.length; i++) {
          const text = matrix.chars[Math.floor(Math.random() * matrix.chars.length)];
          const x = i * matrix.fontSize;
          const y = matrix.drops[i] * matrix.fontSize;
          // head
          mctx.fillStyle = '#00ff99';
          mctx.fillText(text, x, y);
          // trailing characters with fading alpha to create longer green lines
          const tailAlphas = [0.5, 0.35, 0.25, 0.18, 0.12, 0.08];
          for (let k = 1; k <= tailAlphas.length; k++) {
            mctx.fillStyle = `rgba(0,255,153,${tailAlphas[k-1]})`;
            mctx.fillText(text, x, y - k * matrix.fontSize);
          }
          if (y > h && Math.random() > 0.965) matrix.drops[i] = 0;
          // slower: advance by 0.5 instead of 1
          matrix.drops[i] += 0.5;
        }
      }

      function drawPlatform(p) {
        const r = 8; const y = p.y; const x = p.x; const w = p.w; const h = 12;
        // shadow
        ctx.fillStyle = 'rgba(0,0,0,.25)'; ctx.fillRect(x+2, y+6, w, h);
        // body
        const grad = ctx.createLinearGradient(0, y, 0, y+h);
        if (p.type === 'break') { grad.addColorStop(0, '#3b2020'); grad.addColorStop(1, '#6a2a2a'); }
        else if (p.type === 'move') { grad.addColorStop(0, '#0a3a2a'); grad.addColorStop(1, '#0f6b4b'); }
        else { grad.addColorStop(0, '#0d3a23'); grad.addColorStop(1, '#1dbf73'); }
        ctx.fillStyle = grad; roundRect(ctx, x, y, w, h, r); ctx.fill();
        // broken visual
        if (p.broken) { ctx.strokeStyle = 'rgba(0,0,0,.5)'; ctx.beginPath(); ctx.moveTo(x+4,y+3); ctx.lineTo(x+w-4,y+h-3); ctx.moveTo(x+w-4,y+3); ctx.lineTo(x+4,y+h-3); ctx.stroke(); }
      }

             function drawEnemy(e) {
         const img = assets[e.sprite];
         if (img && img.complete && img.naturalWidth > 0) {
           ctx.drawImage(img, e.x, e.y, e.w, e.h);
         } else {
           // fallback: neon slime orb (green)
           const gr = ctx.createRadialGradient(e.x + e.w/2, e.y + e.h/2, 6, e.x + e.w/2, e.y + e.h/2, e.w/1.2);
           gr.addColorStop(0, '#5cffb0'); gr.addColorStop(1, 'rgba(92,255,176,0)');
           ctx.fillStyle = gr; ctx.beginPath(); ctx.arc(e.x + e.w/2, e.y + e.h/2, e.w/2, 0, Math.PI*2); ctx.fill();
           ctx.fillStyle = '#00ff99'; ctx.fillRect(e.x+e.w*0.2, e.y+e.h*0.45, e.w*0.6, 6);
         }
       }

                           function drawPowerup(pu) {
          if (pu.type === 'rocket') {
            if (rocketImg && rocketImg.complete && rocketImg.naturalWidth > 0) {
              ctx.drawImage(rocketImg, pu.x, pu.y, pu.w, pu.h);
            } else {
              ctx.fillStyle = '#ffd166';
              ctx.fillRect(pu.x, pu.y, pu.w, pu.h);
            }
          } else if (pu.type === 'hat') {
            if (hatImg && hatImg.complete && hatImg.naturalWidth > 0) {
              ctx.drawImage(hatImg, pu.x, pu.y, pu.w, pu.h);
            } else {
              ctx.fillStyle = '#ff6b6b';
              ctx.fillRect(pu.x, pu.y, pu.w, pu.h);
            }
          }
        }

             function drawPlayer() {
         const x = player.x, y = player.y, w = player.w, h = player.h;
         if (assets.player && assets.player.complete && assets.player.naturalWidth > 0) {
           ctx.drawImage(assets.player, x, y, w, h);
         } else {
           // fallback: simple green-toned avatar
           ctx.save();
           ctx.translate(x, y);
           // body
           roundRect(ctx, 4, 8, w-8, h-12, 8); ctx.fillStyle = '#158a52'; ctx.fill();
           // visor
           ctx.fillStyle = '#02130d'; roundRect(ctx, 10, 18, w-20, 16, 6); ctx.fill();
           ctx.fillStyle = '#e6fff2'; ctx.fillRect(12, 21, w-24, 3);
           // antenna
           ctx.fillStyle = '#6bffa6'; ctx.fillRect(w/2-3, 4, 6, 10);
           // glow
           ctx.globalAlpha = .2; ctx.fillStyle = '#64ffb8'; ctx.beginPath(); ctx.arc(w/2, h, w*.9, Math.PI, 2*Math.PI); ctx.fill(); ctx.globalAlpha = 1;
           ctx.restore();
         }
       }

      function roundRect(ctx, x, y, w, h, r) {
        const rr = Math.min(r, w/2, h/2);
        ctx.beginPath();
        ctx.moveTo(x+rr, y);
        ctx.arcTo(x+w, y, x+w, y+h, rr);
        ctx.arcTo(x+w, y+h, x, y+h, rr);
        ctx.arcTo(x, y+h, x, y, rr);
        ctx.arcTo(x, y, x+w, y, rr);
        ctx.closePath();
      }

             // Initial setup
       renderScoreLists();
       ui.score.textContent = '0';
       
       // Load saved name only if input is empty
       const nameInput = document.getElementById('playerName');
       if (nameInput && !nameInput.value.trim()) {
         const savedName = localStorage.getItem(NAME_KEY);
         if (savedName) nameInput.value = savedName;
       }

      // Accessibility: allow Enter to start when in menu
      document.addEventListener('keydown', e => { if (state === State.MENU && (e.key === 'Enter' || e.key === ' ')) startGame(); });

      // Online Highscore placeholder (explain usage)
      // To enable online leaderboard, implement POST to your backend here with { name, score }
      // and fetch/display the global list alongside the local one. Call it inside endGame().

    </script>
  </body>
</html>


